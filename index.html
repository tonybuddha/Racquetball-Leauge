<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Racquetball League Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://kit.fontawesome.com/a570c9ac95.js" crossorigin="anonymous"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        /* Style for the active tab */
        .tab-active {
            border-bottom: 3px solid #f97316; /* Orange-500 */
            color: #f97316;
            font-weight: 700;
        }
        /* Custom scrollbar for better mobile look */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #f97316;
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #1f2937;
        }
        .ranking-card:nth-child(1) { @apply bg-yellow-500/10 border-yellow-500; }
        .ranking-card:nth-child(2) { @apply bg-gray-400/10 border-gray-400; }
        .ranking-card:nth-child(3) { @apply bg-yellow-700/10 border-yellow-700; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">

    <div id="app" class="max-w-4xl mx-auto py-4 px-2 sm:px-4">
        <header class="text-center mb-6">
            <h1 class="text-3xl font-extrabold text-white tracking-tight">
                <i class="fas fa-table-tennis mr-2 text-orange-500"></i> League Tracker
            </h1>
            <!-- The status text here will no longer show the User ID -->
            <p id="auth-status" class="text-xs text-gray-500 mt-1"></p>
        </header>

        <!-- Navigation Tabs -->
        <nav class="flex justify-around border-b border-gray-700 mb-6 sticky top-0 bg-gray-900/90 z-10 backdrop-blur-sm shadow-lg rounded-b-lg">
            <button class="tab-button px-4 py-3 text-sm transition duration-150" data-tab="rankings">Rankings</button>
            <button class="tab-button px-4 py-3 text-sm transition duration-150" data-tab="log">Log Match</button>
            <button class="tab-button px-4 py-3 text-sm transition duration-150" data-tab="schedule">Schedule</button>
            <button class="tab-button px-4 py-3 text-sm transition duration-150" data-tab="rules">Rules</button>
            <!-- Reset button -->
            <button id="reset-btn" class="px-2 text-xs text-red-500 hover:text-red-400 transition duration-150" title="Reset League"><i class="fas fa-undo"></i></button>
        </nav>

        <!-- Main Content Area -->
        <main id="content" class="p-2 sm:p-4 rounded-xl shadow-2xl bg-gray-800/70 custom-scrollbar"></main>
    </div>

    <!-- Modals -->
    <div id="modal-container" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
        <!-- Reset Modal Content -->
        <div id="reset-modal" class="bg-gray-800 p-6 rounded-xl shadow-2xl max-w-sm w-full transform transition-all scale-95 opacity-0">
            <h3 class="text-xl font-bold mb-4 text-red-400">Confirm League Reset</h3>
            <p class="text-sm text-gray-300 mb-4">Are you sure you want to reset all players, rankings, and match history? This action is irreversible.</p>
            <label for="reset-password" class="block text-sm font-medium mb-1">Enter Password:</label>
            <input type="password" id="reset-password" class="w-full p-2 mb-4 bg-gray-700 border border-gray-600 rounded-lg text-gray-100 focus:ring-orange-500 focus:border-orange-500" placeholder="Password">
            <p id="reset-error" class="text-red-500 text-xs mb-4 hidden">Incorrect password.</p>
            <div class="flex justify-end space-x-3">
                <button onclick="hideResetModal()" class="px-4 py-2 text-sm font-medium rounded-lg text-gray-300 bg-gray-700 hover:bg-gray-600 transition">Cancel</button>
                <button onclick="handleResetAttempt()" class="px-4 py-2 text-sm font-medium rounded-lg text-white bg-red-600 hover:bg-red-700 transition">Reset Everything</button>
            </div>
        </div>

        <!-- Message/Loading Modal -->
        <div id="message-modal" class="hidden bg-gray-800 p-6 rounded-xl shadow-2xl max-w-sm w-full transform transition-all scale-95 opacity-0">
            <h3 id="message-title" class="text-xl font-bold mb-4 text-orange-400"></h3>
            <p id="message-text" class="text-sm text-gray-300 mb-4"></p>
            <div id="message-spinner" class="animate-spin h-6 w-6 border-4 border-orange-500 border-t-transparent rounded-full mx-auto hidden"></div>
            <div id="message-actions" class="flex justify-end space-x-3 hidden">
                <button onclick="hideMessageModal()" class="px-4 py-2 text-sm font-medium rounded-lg text-white bg-orange-600 hover:bg-orange-700 transition">Close</button>
            </div>
        </div>
    </div>


    <!-- Firebase/JS Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query, runTransaction, arrayUnion, deleteDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- IMPORTANT: EXTERNAL CONFIGURATION FOR GITHUB PAGES / LOCAL RUNNING ---
        // If you are running this file outside of the original Canvas environment (e.g., on GitHub Pages),
        // you must replace the empty object below with your actual Firebase Project Configuration (from your Project Settings).
        // If left empty, the app will display a Configuration Error message instead of crashing.
        const USER_FIREBASE_CONFIG = {
 apiKey: "AIzaSyAPNH2AEvzmgOYKG7lnJb823feAQO9uTec",
  authDomain: "racquetball-57e1c.firebaseapp.com",
  projectId: "racquetball-57e1c",
  storageBucket: "racquetball-57e1c.firebasestorage.app",
  messagingSenderId: "684587201391",
  appId: "1:684587201391:web:b43af518a7735225a8ae9a",
  measurementId: "G-FJLF3PGZYY"
}; // <<< PASTE YOUR FIREBASE CONFIG OBJECT HERE (e.g., { apiKey: "...", authDomain: "...", ... })
        
        // Firestore Configuration - Uses environment variables if available, otherwise uses the user-defined config.
        setLogLevel('Debug');
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-racquetball-league-2025';
        
        let firebaseConfig = USER_FIREBASE_CONFIG;

        // Check for Canvas environment variables (if running in that context)
        if (typeof __firebase_config !== 'undefined' && Object.keys(JSON.parse(__firebase_config)).length > 0) {
            firebaseConfig = JSON.parse(__firebase_config);
        }
        
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, db, auth, userId = null;
        let players = [];
        let matches = [];
        let activeTab = 'rankings';
        let isAuthReady = false;
        
        // --- Hardcoded Rules Content (Bypasses API fetch, fixing the issue) ---
        let rulesContent = `
## Official Racquetball Rules (League Standard)

These rules are based on standard professional racquetball regulations, adapted for our league play.

### I. Serving Rules

1.  **Start of Play:** The server must hit the ball from the **service zone** (between the short line and the service line).
2.  **Service Motion:** The ball must hit the **front wall first** and then, without touching the floor, land behind the **short line**.
3.  **Hinderance:** The receiver must stand behind the receiving line until the ball passes the short line.
4.  **Foot Faults:** The server must remain in the service zone until the ball passes the short line. Stepping over the service line before the ball passes the short line is a fault.

### II. Faults

A **Fault** results in the loss of serve (known as a "Sideout"). The server is allowed **two** faults. A third fault in a row results in a sideout.

1.  **Long Service:** The served ball hits the front wall and then hits the back wall *before* bouncing on the floor (not a fault if touched by the ceiling).
2.  **Short Service:** The served ball hits the floor *before* crossing the short line.
3.  **Ceiling Service:** The served ball hits the ceiling *after* hitting the front wall.

### III. Rallies

1.  **Return:** The ball must be hit before it bounces twice.
2.  **Legal Hit:** The ball must hit the front wall either directly or after hitting one side wall.
3.  **Sideout:** If the server loses the rally, a sideout occurs, and the opponent becomes the new server.
4.  **Point:** If the receiver loses the rally, the server scores a point and continues serving (in standard rules, only the server can score).

### IV. Scoring (League Specific)

1.  **Game Format:** Matches consist of **three** games.
2.  **Game Score:** Each game is played until a predetermined score (e.g., 15) is reached, with no requirement for a two-point difference.
3.  **League Points:** For league ranking:
    * The **winner** of a single game (by score) is awarded **3 points** in the league rankings.
    * The total league points are the sum of points earned from all games played.
4.  **Weekly Limit:** Players are limited to logging **one match per week** (Monday to Sunday) to ensure fair play and rotation.
`;
        const MAX_PLAYERS = 8;
        const RESET_PASSWORD = 'reset'; // The requested password for league reset

        // --- Firebase Initialization and Auth ---

        async function initApp() {
            try {
                if (Object.keys(firebaseConfig).length === 0) {
                    document.getElementById('auth-status').textContent = 'ERROR: Config Missing';
                    showMessageModal("Configuration Error", "Database connection failed. To enable real-time persistence (required for this app), you must paste your Firebase project configuration object into the USER_FIREBASE_CONFIG variable in the script tag.");
                    console.error("Firebase configuration is missing. Cannot initialize app.");
                    return; // Stop initialization gracefully
                }
                
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                document.getElementById('auth-status').textContent = 'Connecting...';

                // Sign In using custom token or anonymously
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        isAuthReady = true;
                        // Hiding the long User ID as requested by the user.
                        document.getElementById('auth-status').textContent = 'Ready to play!'; 
                        loadData();
                        renderApp();
                    } else {
                        isAuthReady = true;
                        document.getElementById('auth-status').textContent = 'Authentication failed.';
                    }
                });

            } catch (error) {
                console.error("Firebase initialization failed:", error);
                showMessageModal("Error", "Could not connect to the database. Check console for details.");
            }
        }

        // --- Data Loading (Real-time Listener) ---

        function getLeagueDocRef() {
            return doc(db, 'artifacts', appId, 'public', 'data', 'leagueData', 'currentLeague');
        }

        function getMatchesCollectionRef() {
            return collection(db, 'artifacts', appId, 'public', 'data', 'matches');
        }

        function loadData() {
            if (!db) return;

            // 1. Players Snapshot (Main League Data)
            onSnapshot(getLeagueDocRef(), (docSnapshot) => {
                const data = docSnapshot.data() || { players: [] };
                players = data.players || [];
                players = calculateRankings(players);
                renderApp();
            }, (error) => {
                console.error("Error fetching league data:", error);
            });

            // 2. Matches Snapshot
            onSnapshot(query(getMatchesCollectionRef()), (snapshot) => {
                matches = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                players = calculateRankings(players); // Recalculate rankings on new match data
                renderApp();
            }, (error) => {
                console.error("Error fetching match data:", error);
            });
        }

        // --- Core Logic ---

        function calculateRankings(currentPlayers) {
            const playerStats = currentPlayers.map(p => ({
                id: p.id,
                name: p.name,
                points: 0,
                matchesPlayed: 0,
                wins: 0,
                losses: 0
            }));

            for (const match of matches) {
                const statsA = playerStats.find(p => p.id === match.playerA);
                const statsB = playerStats.find(p => p.id === match.playerB);

                if (!statsA || !statsB) continue;

                statsA.matchesPlayed++;
                statsB.matchesPlayed++;

                for (const game of match.games) {
                    const winnerId = game.winner;
                    const loserId = (winnerId === match.playerA) ? match.playerB : match.playerA;

                    if (winnerId === statsA.id) {
                        statsA.points += 3;
                        statsA.wins++;
                    } else if (winnerId === statsB.id) {
                        statsB.points += 3;
                        statsB.wins++;
                    }

                    if (loserId === statsA.id) {
                        statsA.losses++;
                    } else if (loserId === statsB.id) {
                        statsB.losses++;
                    }
                }
            }

            // Sort logic: Points (Desc), Wins (Desc), Name (Asc)
            playerStats.sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                if (b.wins !== a.wins) return b.wins - a.wins;
                return a.name.localeCompare(b.name);
            });

            return playerStats.map((stats, index) => ({
                ...currentPlayers.find(p => p.id === stats.id),
                ...stats,
                rank: index + 1
            }));
        }
        
        function getStartOfWeek(dateString) {
            const date = new Date(dateString + 'T00:00:00'); // Ensure UTC midnight to avoid timezone issues
            const day = date.getDay();
            // 0 = Sunday, 1 = Monday. Calculate the previous Monday.
            const diff = date.getDate() - day + (day === 0 ? -6 : 1); 
            date.setDate(diff);
            return date.toISOString().split('T')[0];
        }

        async function checkWeeklyLimit(playerAId, playerBId, matchDate) {
            const startOfWeek = getStartOfWeek(matchDate);

            // Fetch all matches from the start of the week for performance
            const matchDocs = await getDocs(getMatchesCollectionRef());
            const weeklyMatches = matchDocs.docs
                .map(doc => doc.data())
                .filter(match => getStartOfWeek(match.date) === startOfWeek);
            
            let playerAMatches = 0;
            let playerBMatches = 0;

            for (const match of weeklyMatches) {
                if (match.playerA === playerAId || match.playerB === playerAId) {
                    playerAMatches++;
                }
                if (match.playerA === playerBId || match.playerB === playerBId) {
                    playerBMatches++;
                }
            }
            
            const playerA = players.find(p => p.id === playerAId)?.name;
            const playerB = players.find(p => p.id === playerBId)?.name;
            
            if (playerAMatches > 0) return `${playerA} has already played a match this week (Week starting ${startOfWeek}).`;
            if (playerBMatches > 0) return `${playerB} has already played a match this week (Week starting ${startOfWeek}).`;

            return null; // No conflict
        }

        // --- DOM Rendering and Handlers ---

        function renderApp() {
            if (!isAuthReady) return;

            // Update tab button styles
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('tab-active');
                if (btn.dataset.tab === activeTab) {
                    btn.classList.add('tab-active');
                }
            });

            const contentEl = document.getElementById('content');
            contentEl.innerHTML = '';

            switch (activeTab) {
                case 'rankings':
                    renderRankings(contentEl);
                    break;
                case 'log':
                    renderLogMatch(contentEl);
                    break;
                case 'schedule':
                    renderSchedule(contentEl);
                    break;
                case 'rules':
                    renderRules(contentEl);
                    break;
            }
        }

        // --- Tab 1: Rankings/Player Management ---

        function renderRankings(container) {
            const playerCount = players.length;
            const maxReached = playerCount >= MAX_PLAYERS;
            const rankingsHTML = players.map(p => `
                <div class="ranking-card flex items-center p-4 mb-3 bg-gray-700 rounded-xl shadow-md border-l-4 border-orange-500">
                    <div class="w-8 text-2xl font-black text-orange-500 mr-4">${p.rank}.</div>
                    <div class="flex-grow">
                        <p class="text-lg font-semibold">${p.name}</p>
                    </div>
                    <div class="text-right">
                        <p class="text-xl font-bold">${p.points}</p>
                        <p class="text-xs text-gray-400">Pts | ${p.wins}W-${p.losses}L</p>
                    </div>
                </div>
            `).join('');

            container.innerHTML = `
                <h2 class="text-2xl font-bold mb-4">Player Rankings (${playerCount}/${MAX_PLAYERS})</h2>

                <div class="mb-6 p-4 bg-gray-700 rounded-xl shadow-lg ${maxReached ? 'opacity-50 cursor-not-allowed' : ''}">
                    <h3 class="text-lg font-semibold mb-3">Add New Player</h3>
                    <input type="text" id="new-player-name" placeholder="Player Name" class="w-full p-3 bg-gray-800 border-gray-600 rounded-lg text-gray-100 placeholder-gray-500 focus:ring-orange-500 focus:border-orange-500" ${maxReached ? 'disabled' : ''}>
                    <button onclick="addPlayer()" class="mt-3 w-full p-3 bg-orange-600 text-white font-bold rounded-lg hover:bg-orange-700 transition" ${maxReached ? 'disabled' : ''}>
                        Add Player
                    </button>
                    ${maxReached ? '<p class="text-red-400 text-sm mt-2 text-center">Maximum 8 players reached.</p>' : ''}
                </div>
                
                <h3 class="text-xl font-bold mb-3 mt-8">Current Standings</h3>
                <div id="rankings-list">
                    ${rankingsHTML || '<p class="text-gray-400">No players added yet. Add players above!</p>'}
                </div>
                <h3 class="text-xl font-bold mb-3 mt-8">Match History</h3>
                <div id="match-history" class="space-y-3">
                    ${matches.length > 0 ? matches.map(m => {
                        const playerAName = players.find(p => p.id === m.playerA)?.name || m.playerA;
                        const playerBName = players.find(p => p.id === m.playerB)?.name || m.playerB;
                        const scoreSummary = m.games.map((g, i) => {
                            const winnerName = players.find(p => p.id === g.winner)?.name || 'N/A';
                            return `<span class="text-xs text-gray-400">Game ${i+1}: ${g.scoreA}-${g.scoreB} (${winnerName} wins 3 Pts)</span>`;
                        }).join(' | ');

                        return `
                            <div class="bg-gray-700 p-3 rounded-lg flex justify-between items-center text-sm">
                                <div>
                                    <p class="font-semibold">${playerAName} vs ${playerBName}</p>
                                    <p class="text-xs text-gray-400">${scoreSummary}</p>
                                </div>
                                <div class="text-right">
                                    <p class="text-xs text-gray-300">${m.date}</p>
                                    <button onclick="deleteMatch('${m.id}')" class="text-red-500 hover:text-red-400 ml-2 text-xs" title="Delete Match"><i class="fas fa-trash-alt"></i></button>
                                </div>
                            </div>
                        `;
                    }).join('') : '<p class="text-gray-400">No matches logged yet.</p>'}
                </div>
            `;
        }

        async function addPlayer() {
            const input = document.getElementById('new-player-name');
            const name = input.value.trim();

            if (!name) return;
            if (players.length >= MAX_PLAYERS) {
                showMessageModal("Limit Reached", `The league is limited to ${MAX_PLAYERS} players.`);
                return;
            }

            const newPlayer = {
                id: crypto.randomUUID(),
                name: name,
                points: 0,
                matchesPlayed: 0
            };

            await runTransaction(db, async (transaction) => {
                const leagueRef = getLeagueDocRef();
                const doc = await transaction.get(leagueRef);
                const currentData = doc.data() || { players: [] };
                const currentPlayers = currentData.players || [];
                
                if (currentPlayers.length < MAX_PLAYERS) {
                    currentPlayers.push(newPlayer);
                    transaction.set(leagueRef, { players: currentPlayers });
                } else {
                    throw new Error(`Maximum player limit (${MAX_PLAYERS}) reached.`);
                }
            });

            input.value = '';
            // Rerender handled by onSnapshot
        }
        
        async function deleteMatch(matchId) {
             showMessageModal("Processing", "Deleting match...", true);
             try {
                const matchRef = doc(getMatchesCollectionRef(), matchId);
                await deleteDoc(matchRef);
                hideMessageModal();
             } catch (error) {
                console.error("Error deleting match:", error);
                showMessageModal("Error", "Failed to delete match. Check console.");
             }
        }


        // --- Tab 2: Log Match ---
        
        let tempMatch = {
            playerAId: '',
            playerBId: '',
            date: new Date().toISOString().split('T')[0],
            gameScores: [
                { scoreA: 0, scoreB: 0 },
                { scoreA: 0, scoreB: 0 },
                { scoreA: 0, scoreB: 0 }
            ]
        };

        function updateTempMatch(field, value, index = null, scoreType = null) {
            if (field === 'playerA') {
                tempMatch.playerAId = value;
            } else if (field === 'playerB') {
                tempMatch.playerBId = value;
            } else if (field === 'date') {
                tempMatch.date = value;
            } else if (field === 'score' && index !== null && scoreType !== null) {
                const scoreValue = parseInt(value) || 0;
                if (scoreValue >= 0) {
                    tempMatch.gameScores[index][scoreType] = scoreValue;
                }
            }
            // Minor partial re-render of the Log form to update validation/summary, but NOT the inputs.
            const summaryEl = document.getElementById('match-summary');
            if (summaryEl) summaryEl.innerHTML = getMatchSummaryHTML();
        }

        function getMatchSummaryHTML() {
            if (!tempMatch.playerAId || !tempMatch.playerBId) return '<p class="text-sm text-gray-500">Select players to see game outcomes.</p>';

            const playerA = players.find(p => p.id === tempMatch.playerAId)?.name;
            const playerB = players.find(p => p.id === tempMatch.playerBId)?.name;

            let html = `<p class="font-semibold mb-2">Match: ${playerA} vs ${playerB}</p>`;

            tempMatch.gameScores.forEach((game, index) => {
                let winner = 'N/A';
                if (game.scoreA > game.scoreB) {
                    winner = playerA;
                } else if (game.scoreB > game.scoreA) {
                    winner = playerB;
                }
                
                const gameResult = (winner === 'N/A') ? 'TBD' : `${winner} wins 3 points.`;

                html += `
                    <div class="text-xs text-gray-400">Game ${index + 1}: ${game.scoreA} - ${game.scoreB} &rarr; <span class="text-orange-400 font-medium">${gameResult}</span></div>
                `;
            });
            return html;
        }

        function renderLogMatch(container) {
            const availablePlayers = players.filter(p => players.length >= 2);
            
            if (availablePlayers.length < 2) {
                container.innerHTML = `
                    <div class="text-center p-8 bg-gray-700 rounded-xl">
                        <i class="fas fa-exclamation-triangle text-yellow-500 text-4xl mb-3"></i>
                        <p class="text-lg font-semibold">Need More Players</p>
                        <p class="text-gray-400">You need at least 2 players registered to log a match. Go to the Rankings tab to add players.</p>
                    </div>
                `;
                return;
            }

            const playerOptions = availablePlayers.map(p => 
                `<option value="${p.id}">${p.name}</option>`
            ).join('');

            const gamesHTML = tempMatch.gameScores.map((game, index) => {
                const gameNum = index + 1;
                return `
                    <div class="p-4 bg-gray-700 rounded-lg shadow-md mb-3">
                        <h4 class="font-semibold text-lg mb-3 text-orange-400">Game ${gameNum}</h4>
                        <div class="flex space-x-3">
                            <!-- Player A Score Input (Player A selected below) -->
                            <div class="flex-1">
                                <label class="block text-xs text-gray-400 mb-1">${players.find(p => p.id === tempMatch.playerAId)?.name || 'Player A'}</label>
                                <input type="number" min="0" value="${game.scoreA}" data-game-index="${index}" data-score-type="scoreA" 
                                    class="score-input w-full p-2 bg-gray-800 border-gray-600 rounded-lg text-gray-100 focus:ring-orange-500 focus:border-orange-500 text-lg font-mono text-center" 
                                    oninput="window.updateScoreInput(event)"
                                >
                            </div>
                            <!-- Player B Score Input (Player B selected below) -->
                            <div class="flex-1">
                                <label class="block text-xs text-gray-400 mb-1">${players.find(p => p.id === tempMatch.playerBId)?.name || 'Player B'}</label>
                                <input type="number" min="0" value="${game.scoreB}" data-game-index="${index}" data-score-type="scoreB" 
                                    class="score-input w-full p-2 bg-gray-800 border-gray-600 rounded-lg text-gray-100 focus:ring-orange-500 focus:border-orange-500 text-lg font-mono text-center" 
                                    oninput="window.updateScoreInput(event)"
                                >
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `
                <h2 class="text-2xl font-bold mb-4">Log New Match (3 Games)</h2>

                <div class="space-y-4 mb-6 p-4 bg-gray-700 rounded-xl shadow-lg">
                    <h3 class="text-lg font-semibold mb-3">Match Details</h3>
                    
                    <label for="match-date" class="block text-sm font-medium mb-1">Date of Match</label>
                    <input type="date" id="match-date" value="${tempMatch.date}" 
                        onchange="window.updateTempMatch('date', this.value)"
                        class="w-full p-3 bg-gray-800 border-gray-600 rounded-lg text-gray-100 focus:ring-orange-500 focus:border-orange-500">
                    
                    <div class="flex space-x-4">
                        <div class="flex-1">
                            <label for="playerA" class="block text-sm font-medium mb-1">Player A</label>
                            <select id="playerA" onchange="window.updateTempMatch('playerA', this.value); window.renderApp();" 
                                class="w-full p-3 bg-gray-800 border-gray-600 rounded-lg text-gray-100 focus:ring-orange-500 focus:border-orange-500">
                                <option value="">--- Select Player A ---</option>
                                ${playerOptions}
                            </select>
                        </div>
                        <div class="flex-1">
                            <label for="playerB" class="block text-sm font-medium mb-1">Player B</label>
                            <select id="playerB" onchange="window.updateTempMatch('playerB', this.value); window.renderApp();" 
                                class="w-full p-3 bg-gray-800 border-gray-600 rounded-lg text-gray-100 focus:ring-orange-500 focus:border-orange-500">
                                <option value="">--- Select Player B ---</option>
                                ${playerOptions}
                            </select>
                        </div>
                    </div>
                </div>

                <div id="score-entry">
                    ${gamesHTML}
                </div>

                <div id="match-summary" class="p-4 mt-6 mb-4 bg-gray-700 rounded-xl border border-orange-500/50">
                    ${getMatchSummaryHTML()}
                </div>

                <button onclick="logMatch()" id="log-match-btn" class="w-full p-4 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 transition disabled:bg-gray-500 disabled:cursor-not-allowed">
                    Submit Match Results
                </button>
            `;
            
            // Re-select currently stored values if they exist (important for maintaining state after player selection)
            document.getElementById('playerA').value = tempMatch.playerAId;
            document.getElementById('playerB').value = tempMatch.playerBId;
            
            // Attach score input listener globally for non-focus-losing updates
            window.updateScoreInput = (event) => {
                const input = event.target;
                const index = parseInt(input.dataset.gameIndex);
                const scoreType = input.dataset.scoreType;
                
                // Update temporary state without triggering a full DOM re-render
                updateTempMatch('score', input.value, index, scoreType);
                
                // CRITICAL: Force the input to keep focus (though modern browsers often maintain it if no full re-render happens)
                // We rely on the selective DOM update in updateTempMatch (only updating summary) to prevent focus loss.
            };
            
            // Expose updateTempMatch to global scope for select/date inputs
            window.updateTempMatch = updateTempMatch;
            window.renderApp = renderApp; 
        }

        async function logMatch() {
            const { playerAId, playerBId, date, gameScores } = tempMatch;

            if (!playerAId || !playerBId || !date) {
                showMessageModal("Validation Error", "Please select both players and a date.");
                return;
            }
            if (playerAId === playerBId) {
                showMessageModal("Validation Error", "Players must be different.");
                return;
            }

            let games = [];
            let totalGamesWon = 0;

            for (const game of gameScores) {
                if (game.scoreA < 0 || game.scoreB < 0) {
                     showMessageModal("Validation Error", "Scores must be zero or positive.");
                     return;
                }
                const isTie = game.scoreA === game.scoreB;
                const winnerId = game.scoreA > game.scoreB ? playerAId : (game.scoreB > game.scoreA ? playerBId : null);

                if (isTie) {
                    showMessageModal("Validation Error", "Game scores cannot be tied.");
                    return;
                }
                
                games.push({ 
                    winner: winnerId, 
                    scoreA: game.scoreA, 
                    scoreB: game.scoreB 
                });
                if (winnerId) totalGamesWon++;
            }
            
            if (totalGamesWon < 3) {
                 showMessageModal("Validation Error", "All three games must have a winner.");
                 return;
            }
            
            showMessageModal("Processing", "Checking weekly limit...", true);
            const conflict = await checkWeeklyLimit(playerAId, playerBId, date);
            
            if (conflict) {
                showMessageModal("Weekly Limit Error", conflict);
                return;
            }
            
            showMessageModal("Processing", "Submitting match and updating rankings...", true);

            const matchData = {
                date: date,
                playerA: playerAId,
                playerB: playerBId,
                games: games
            };
            
            try {
                // Add match to the collection
                await setDoc(doc(getMatchesCollectionRef()), matchData);
                
                // Reset temp match state
                tempMatch = { 
                    playerAId: '', 
                    playerBId: '', 
                    date: new Date().toISOString().split('T')[0],
                    gameScores: [{ scoreA: 0, scoreB: 0 }, { scoreA: 0, scoreB: 0 }, { scoreA: 0, scoreB: 0 }]
                };
                
                hideMessageModal();
                showMessageModal("Success", "Match logged successfully! Rankings updated.", false, true);

            } catch (error) {
                console.error("Error logging match:", error);
                showMessageModal("Error", "Failed to log match. Check console for details.");
            }
        }
        
        // --- Tab 3: Schedule ---

        function generateSchedule(playerIds) {
            if (playerIds.length !== 8) {
                return null;
            }
            
            // Round-robin schedule generation (Circle Method)
            let n = 8;
            let players = [...playerIds];
            let fixed = players[0];
            let rotating = players.slice(1);
            let schedule = [];

            for (let week = 1; week <= 7; week++) {
                let matches = [];
                // Fixed player plays rotating player at index 0
                matches.push([fixed, rotating[0]]);

                // Other players play across the circle
                for (let i = 1; i < n / 2; i++) {
                    matches.push([rotating[i], rotating[n - 1 - i]]);
                }
                schedule.push({ week, matches });
                
                // Rotate the rotating players (shift all by one, move the last one to the front)
                rotating.unshift(rotating.pop());
            }

            return schedule;
        }

        function renderSchedule(container) {
            const scheduleContainer = document.createElement('div');
            scheduleContainer.className = 'p-4 bg-gray-700 rounded-xl shadow-lg';
            
            if (players.length !== MAX_PLAYERS) {
                scheduleContainer.innerHTML = `
                    <div class="text-center p-8">
                        <i class="fas fa-calendar-alt text-4xl mb-3 text-yellow-500"></i>
                        <p class="text-lg font-semibold mb-2">Schedule Not Ready</p>
                        <p class="text-gray-400">The schedule requires exactly ${MAX_PLAYERS} players. Currently, you have ${players.length}.</p>
                    </div>
                `;
                container.appendChild(scheduleContainer);
                return;
            }
            
            const playerMap = new Map(players.map(p => [p.id, p.name]));
            const playerIds = players.map(p => p.id);
            const schedule = generateSchedule(playerIds);
            
            let scheduleHTML = `<h2 class="text-2xl font-bold mb-4">7-Week Round Robin Schedule</h2>`;

            schedule.forEach(weekData => {
                scheduleHTML += `
                    <div class="mb-5 p-4 border border-gray-600 rounded-lg bg-gray-800">
                        <h3 class="text-xl font-bold mb-3 text-orange-400">Week ${weekData.week}</h3>
                        <div class="space-y-2">
                `;
                weekData.matches.forEach((match, index) => {
                    const p1Name = playerMap.get(match[0]);
                    const p2Name = playerMap.get(match[1]);
                    scheduleHTML += `
                        <p class="text-gray-200">
                            <span class="font-semibold">${p1Name}</span> vs <span class="font-semibold">${p2Name}</span>
                        </p>
                    `;
                });
                scheduleHTML += `
                        </div>
                    </div>
                `;
            });
            
            scheduleContainer.innerHTML = scheduleHTML;
            container.appendChild(scheduleContainer);
        }
        
        // --- Tab 4: Rules ---

        // The old fetchRules function was removed, and the content is hardcoded into the rulesContent variable.

        function renderRules(container) {
            
            container.innerHTML = `
                <h2 class="text-2xl font-bold mb-4">Official Racquetball Rules</h2>
                <div class="mb-4">
                    <input type="text" id="rules-search-input" placeholder="Search rules..." 
                        class="w-full p-3 bg-gray-700 border-gray-600 rounded-lg text-gray-100 placeholder-gray-500 focus:ring-orange-500 focus:border-orange-500" 
                        oninput="searchRules(this.value)">
                </div>
                <div id="rules-content" class="prose prose-invert max-w-none text-gray-200 p-4 bg-gray-700 rounded-xl shadow-lg custom-scrollbar h-[60vh] overflow-y-auto">
                    ${markdownToHtml(rulesContent)}
                </div>
            `;
            searchRules(''); // Initial render
        }

        function searchRules(query) {
            const contentEl = document.getElementById('rules-content');
            if (!rulesContent || !contentEl) return;

            const htmlContent = markdownToHtml(rulesContent);
            
            if (query.trim() === '') {
                contentEl.innerHTML = htmlContent;
                return;
            }

            const regex = new RegExp(`(${query.trim()})`, 'gi');
            const highlightedHtml = htmlContent.replace(regex, (match, p1) => 
                `<mark class="bg-yellow-400 text-gray-900 rounded-sm">${p1}</mark>`
            );
            
            contentEl.innerHTML = highlightedHtml;
        }

        // Simple Markdown to HTML conversion (for rules tab)
        function markdownToHtml(markdown) {
            let html = markdown;
            // Headers
            html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
            // Bold
            html = html.replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>');
            // Lists
            html = html.replace(/^\* (.*$)/gim, '<li>$1</li>');
            html = html.replace(/(\n<li>.*<\/li>)/gs, '<ul>$1</ul>');
            // Paragraphs
            html = html.replace(/\n\n/g, '</p><p>');
            html = `<p>${html}</p>`;
            return html;
        }


        // --- Reset Logic ---

        function showResetModal() {
            const container = document.getElementById('modal-container');
            const modal = document.getElementById('reset-modal');
            document.getElementById('reset-password').value = '';
            document.getElementById('reset-error').classList.add('hidden');
            
            container.classList.remove('hidden');
            // Trigger animation
            setTimeout(() => {
                modal.classList.remove('opacity-0', 'scale-95');
                modal.classList.add('opacity-100', 'scale-100');
            }, 10);
        }

        function hideResetModal() {
            const container = document.getElementById('modal-container');
            const modal = document.getElementById('reset-modal');
            
            modal.classList.remove('opacity-100', 'scale-100');
            modal.classList.add('opacity-0', 'scale-95');
            
            setTimeout(() => {
                container.classList.add('hidden');
            }, 300);
        }
        
        function showMessageModal(title, text, showSpinner = false, showClose = false) {
            const container = document.getElementById('modal-container');
            const modal = document.getElementById('message-modal');
            
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-text').textContent = text;
            
            document.getElementById('message-spinner').classList.toggle('hidden', !showSpinner);
            document.getElementById('message-actions').classList.toggle('hidden', !showClose);
            
            container.classList.remove('hidden');
            modal.classList.remove('hidden');
            // Trigger animation
            setTimeout(() => {
                modal.classList.remove('opacity-0', 'scale-95');
                modal.classList.add('opacity-100', 'scale-100');
            }, 10);
        }

        function hideMessageModal() {
            const container = document.getElementById('modal-container');
            const modal = document.getElementById('message-modal');
            
            modal.classList.remove('opacity-100', 'scale-100');
            modal.classList.add('opacity-0', 'scale-95');
            modal.classList.add('hidden');
            
            setTimeout(() => {
                container.classList.add('hidden');
            }, 300);
        }

        async function handleResetAttempt() {
            const passwordInput = document.getElementById('reset-password');
            const password = passwordInput.value.trim();
            const errorEl = document.getElementById('reset-error');

            if (password !== RESET_PASSWORD) {
                errorEl.classList.remove('hidden');
                passwordInput.value = '';
                return;
            }

            hideResetModal();
            showMessageModal("Resetting League", "Clearing all players and match history...", true);

            try {
                // 1. Reset League Doc (Players)
                const leagueRef = getLeagueDocRef();
                await setDoc(leagueRef, { players: [] });
                
                // 2. Delete all Match Docs (This is potentially expensive, but safe for a small league)
                const matchCollection = getMatchesCollectionRef();
                const q = query(matchCollection);
                const snapshot = await getDocs(q);
                
                const deletePromises = [];
                snapshot.forEach((doc) => {
                    deletePromises.push(deleteDoc(doc.ref));
                });
                await Promise.all(deletePromises);

                showMessageModal("Reset Complete", "The league has been successfully reset. Start adding new players!", false, true);

            } catch (error) {
                console.error("League reset failed:", error);
                showMessageModal("Error", "Failed to complete reset. Check console for details.");
            }
        }
        
        // --- Event Listeners and Global Setup ---

        document.addEventListener('DOMContentLoaded', () => {
            initApp();
            
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    activeTab = e.target.dataset.tab;
                    renderApp();
                });
            });

            document.getElementById('reset-btn').addEventListener('click', showResetModal);
            
            // Expose global functions for HTML inline handlers
            window.addPlayer = addPlayer;
            window.logMatch = logMatch;
            window.showResetModal = showResetModal;
            window.hideResetModal = hideResetModal;
            window.handleResetAttempt = handleResetAttempt;
            window.showMessageModal = showMessageModal;
            window.hideMessageModal = hideMessageModal;
            window.searchRules = searchRules;
            window.deleteMatch = deleteMatch;
        });

    </script>
</body>
</html>
